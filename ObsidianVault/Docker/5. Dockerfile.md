#Docker 

- Инструкции, по которым Docker собирает образ
- Аналог рецепта: шаги сборки, зависимости, команды
- Текстовый файл `Dockerfile`, обычно рядом с исходным кодом
- Позволяет создавать воспроизводимые, консистентные окружения

> Dockerfile - это как пошаговый чек-лист для повара DevOps'а

### Базовая структура Dockerfile

- `FROM` - базовый образ
-  `WORKDIR` - рабочая директория
- `COPY` - скопировать файлы в образ
- `RUN` - выполнить команды при сборке
- `CMD` / `ENTRYPOINT` - команда запуска контейнера
- `ENV` - переменные внутри
- `ARG` - переменные при сборке
- `EXPOSE` - документация по порту

### multistage-сборка

- Отделяем сборку от запуска
```Docker
FROM golang:1.20 as builder
WORKDIR /build
COPY . .
RUN go build -o app

FROM alpine
COPY --from=builder /build/app /app
ENTRYPOINT ["/app"]
```

Все данные до второго `FROM` складываются в память, но не попадают в финальный образ. В финальный образ с `alpine` будут скопированы только нужные файлы, а все сопутствующие артефакты(то что сборщик golang намусорил) в сборку не попадут

- Меньший размер
- Уменьшение attack surface

> Каждая инструкция = новый слой

### Инструменты и best practices

- `hadoling` - линтер для Dockerfile
- `.dockerignore` - не тянуть в образ все подряд
- `docker history` - покажет "жирные" слои
- `dive` - визуальный анализ образа
- `--squash` (экспериментально) - объединение слоев
- Минимизация:
	- не держать лишние зависимости
	- не собирать frontend внутри образа backend

## Можно ли без Dockerfile