#CSharp 

[[Шаблон TAP]]
Находится в `System.Threading.Tasks`

- Абстракция над `ThreadPool`, **высокоуровневый способ** организации асинхронной и параллельной работы.    
- Управляется планировщиком (`TaskScheduler`).    
- Позволяет `await`, продолжения, отмену, композицию (`WhenAll`, `WhenAny`), цепочки и т.д.

`Task` (задача) - конструкция, которая реализует модель параллельной обработки, основанной на обещаниях (Promise). Задача "обещает", что работа будет выполнена позже, позволяя взаимодействовать с помощью обещания с чистым API

> [!info]-  Future and Promise
> Существует стратегия параллельных вычислений. Future - представление переменной доступной для чтения (то есть ссылка на еще неполученный результат). Promise - это контейнер, который завершает указанное действие(асинхронная функция)

[[WhenAll vs WaitAll]]
Виды задач:
- Холодная задача - создает с помощью контструктора `Task` и ожидает команды на запуск
	```C#
	Task task = new Task(new Action(Download));
	task.Start();
	```
- Горячая задача - запускается сразу при создании([[Класс TaskFactory]] или метод `Run()`)
	```C#
	TaskFactory taskFactory = new TaskFactory();
	taskFactory.StartNew(new Action(Download));
	
	Task.Run(new Action(Download));
	```

С задачами используются делегаты `Action`(если задача ничего не возвращает) и `Func`(если есть возварщаемое значение)
```C#
Task task1 = new Task(new Action(Method));

Task<int> task2 = new Task<int>(new Func<int>(GetIntMethod));
```

### Свойства класса Task
- `CurrentId` - идентификатор задачи
- `ComplitedTask` - возвращает завершенную задачу
- `CreationOptions` - настройки задачи(задаются при создании)[[Настройки TaskCreationOptions]]
- `IsComplited / IsCanceled` - свойства дают true/false
- `Status` - [[Статус задачи Task]]
- `Exception` - исключение задачи
- `Id` - айдишник задачи(запрашивается на экземпляре задачи)
- `AsyncState` - состояние задачи
- `IsFaulted` - были ли провалена задача

### await Task.Yield()

Эта конструкция прерывает текущий метод и сразу же планирует его продолжение в текущем контексте синхронизации.

- UI - дает обработать накопленные события отрисовки интерфейса
- Очистка стека вызова

Вы можете использовать `await Task.Yield();` в асинхронном методе, чтобы принудительно завершить его асинхронно. Если имеется текущий контекст синхронизации SynchronizationContext, оставшаяся часть выполнения метода будет возвращена в этот контекст.


