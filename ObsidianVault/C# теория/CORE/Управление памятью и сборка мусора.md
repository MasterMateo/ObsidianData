#CSharp 

- CLR управляет памятью (так как мы пишем управляемый код)
- GC (garbage collector) - сборщик мусора удаляет из памяти "ненужные" объекты
- Чтобы определить какие объекты стали "недостижимы", CLR строит граф достижимости всех объектов
- GC запускается раз в какой-то промежуток времени, этот момент недетерминирован

![[Pasted image 20230823205950.png]]

- Все объекты деляться на управляемые и неуправляемые
- Неуправляемые объекты - объекты, которые содержат неуправляемые ресурсы
- Неуправляемые ресурсы - системные ресурсы, такие как объекты для чтения файлов, подключения к БД, сети и тд. О таких ресурсах GC не знает
- Управляемые объекты - все объекты, не содержащие неуправляемых ресурсов
- Если неуправляемый объект не был очищен явно, то может возникнуть утечка памяти

В СSharp предусмотрено 2 способа работы с неуправляемыми ресурсами:
1. System.Object определяет метод Finalize(). Все классы могут переобпределить этот метод(по умолчанию не переопределяют). Этот метод вызывается GC перед тем как очистить память из под объекта(только для тех, которые его переопределили, такие объекты называются финализируемыми). Поддержка такого механизма финализации дает возможность "бесшовную" вставления кода, который освобождает неуправляемые ресурсы. (Неявный метод очистки памяти). Такой метод имеет некоторые особенности:
	1. Момент финализации недетерминирован
	2. Когда CLR вызывает Finalize(), он становится в очередь на освобождение памяти из под него. Память будет очищена (изъята) только при следующей сборке мусора
2. System.IDisposable определяет метод Dispose(). Если класс содержит в себе неуправляемый ресурс можно предоставить клиенту возможность унаследовать его от интерфейса IDisposable и внутри метода Dispose() вручную почистить.
	1. Типы реализующие IDisposable могут быть обернуты в using: `using (SqlConnection conn = new SqlConnection()) {}` (будет скомпилированно с оберткой написанной строчки в блок *try - finally* с реализацией метода Dispose())

> Не стоит писать классы работающие с управляемыми и неуправляемыми ресурсами!


### Режимы работы сборщика мусора

Сборщик мусора в .NET имеет два основных режима работы: режим рабочей станции и режим сервера, а также два подрежима: параллельный и непараллельный. Параллельный режим рабочей станции используется в настольных приложениях, а режим сервера — в серверных, например, в ASP.NET.

В параллельном режиме рабочей станции, .NET пытается избежать долгой приостановки приложения за счет того, что параллельно с работой потоков программы, в фоновом режиме работает и поток сборщика мусора, который находит объекты для уничтожения.

В непараллельном серверном режиме, .NET приостанавливает работу приложения на время работы сборщика мусора. В целом это более эффективно, чем параллельный режим — сборка мусора занимает столько же времени, но при этом ей не приходится бороться с продолжающей работать программой.