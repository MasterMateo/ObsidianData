#СтруктурыДанных 
1. Позволяют добавлять значение по ключу и затем извлекать их по тому же ключу
2. Ключ не обязан быть целым числом
3. Есть 4 основных реализации словаря:
	1. на связном списке
	2. на параллельных массивах
	3. на сбалансированном бинарном дереве
	4. на хэш таблице

# API символьных таблиц

В общем смысле символные таблицы можно разделить на упорядоченные и неупорядоченные. Оба этих вида должны поддерживать следующие члены API:
1. конструктор по умолчанию и конструктор, который позволяет передать кастомный компаратор колючей
2. метод bool TryGet(TKey key) - возвращает True если значение было найдено
3. метод void Add(TKey key, TValue val) - добавляет пару ключ-значение в таблицу (ключ не может быть null)
4. bool Remove(TKey) - удаляет пару ключ-значение
5. bool Contains(TKey key) - проверяет существование ключа в таблицу
6. bool IsEmpty() - вспомогательный, возвращает True, если в таблице нет значений
7. int Count() - возвращает количество пар ключ-значение в таблице
8. IEnumerable< TKey > Keys() - возвращает количество ключей значений

### Различия отсортированных(упорядоченных) и неотсортированных(неупорядоченных) символьных таблиц:
1. Отсортированные таблицв имеют преимущество над неотсоритрованными в отдельно взятых ситуациях
2. Tkey Min() - наименьший ключ
3. TKey Max() - наибольший ключ
4. void RemoveMin() - удаляет наименьший ключ
5. void RemoveMax() - удаляет наибольший ключ
6. TKey Floor(TKey key) - взять наибольший ключ, который меньше и равен указанному ключу
7. TKey Ceiling(TKey key) - взять наименьший ключ, который больше или равен указанному ключу
8. int Rank(TKey key) - считает количество ключей, которые меньше указанного ключа
9. TKey Select(int k) - позволяет найти ключ определенного ранга (обратный Rank)
10. int Range(TKey a, TKey b) - считает кол-во ключей между ключами a и b

### Характеристика неупорядоченных символьных таблиц(SequentialSearchSt в VS):
1. Поиск и вставка (Get и Add операции) - работает за линейное время
2. Поиск - O(N/2) (при больших N такая реализация не эффективна)
3. Не поддерживает специальные итерации

## Словарь на основе бинарного поиска
1. в худшем и среднем случаях работает за логарифмическое время
2. вставка в худшем случае работает за 2N (линейное время, не приемлимо для очень больших таблиц) 

# Выводы
1. Словари позволяют крайне эффективно извлекать данные по ключу
2. Словари могут быть упорядоченными и неупорядоченными
3. Словарь на последовательном поиска - тривиальная реализация
4. Словарь на бинарном поиске - упорядочен и дает log(N) для поиска и ~N для вставки
