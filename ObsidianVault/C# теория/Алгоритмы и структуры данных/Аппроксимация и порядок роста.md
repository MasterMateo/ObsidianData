#Алгоритмы
Чтобы построить точную математическую модель, описывающую время выполнения любой программы, необходимо принять во внимание 2 фактора:
1. стоимость выполнения каждой инструкции в программе
2. частоту выполнения каждой инструкции в программе

Стоимость выполнения зависит от внешних факторов: среда исполнения, ОС и тд., однако в 99% случаев этот фактор нерелевантен так как современные компьютеры обладают высокой мощностью
Для оценки время выполнения следует сфокусироваться на 2 факторе в большей степени
Обычно используют **тильда-аппроксимацию** для оценки частоты выполнения инструкций в программе
![[Pasted image 20230704104706.png]]

# Порядок роста
![[Pasted image 20230704105335.png]]

1. Есть проблемы, которые требуют алгоритмов с экпоненциальной временной сложностью, их как правило запускают на суперкомпьютерах.
2. Кубическая временная сложность (три вложенных цикла)
3. Квадратический лучше кубического (два вложенных цикла: сортировка выборками и вставками), он уже ближе к "хорошему" порядку роста, но для больших проблем не является практически выполнимым
4. Линейно-логарифмический рост первый, который в большинстве случаев уже достаточен для решения проблем больших размеров(сортировка слияниями, быстрая сортировка), зачастую такие алгоритмы базируются на принципе "разделяй и влавствуй"
5. Линейный рост лучше чем линейно-логарифмический (1 цикл)
6. Логарифмический рост, можно сказать, самый лучший, потому что с алгоритмами, сложность которых равна константе мы на практике не встречаемся(бинарный поиск)
7. Константый рост служит для оценки простейших частей алгоритма, которые не повторяются, их как правило из уравнения оценивающего временную сложность отбрасывают



