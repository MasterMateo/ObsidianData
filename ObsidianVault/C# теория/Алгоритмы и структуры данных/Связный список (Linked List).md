#СтруктурыДанных 

# Тип LinkedList в BCL

1. Doubly-Linked Circular List
2. `AddFirst()/AddLast()` - работают за константу
3. `AddBefore()/AddAfter()` - работают за константу(только если мы знаем какую ноду хотим удалить, иначе добавляется операция поиска)
4. `Remove` - линейное время на операцияю поиска
5. `RemoveFirst/RemoveLast` - за константу
6. `Contains, Find/FindLast` - за линейное время 
7. `CopyTo` - копирует все эелементы в массив (линейное время)
8. `Clear` - удаляет все элеметы списка


Основным строительным блоком этой структуры данных являются **узлы**(Node). Связные списки бывают: Single linked list, Double linked list

Узел служит 2-м целям:
1. узел является хранилищем данных
2. узел указывает на другие узлы (по умолчанию null)

Node chain
![[Pasted image 20230709180322.png]] 

Связанный список представляет собой абстрактный тип данных, который позволяет строить цепочки элементов и предоставляет следующие ключевые операции и элементы:
- содержит ссылку на 1 узел (head)
- содержит ссылку на последний узел (tail)
- Операции:
	- Add
	- Remove
	- Find
	- Enumerate (для прохода по списку в цикле)

В односвязном списке каждый узел содержит только 1 ссылку, которая ссылается на след узел, в то время как в двусвязном списке каждая нода содержит 2 ссылки, которые ссылаются предыдущий и на следующий узлы.

# Односвязный список (Singly-Linked List)

`AddFirst`
![[Pasted image 20230711101946.png]]

Когда в односвязном списке 1 узел, на него указывают Head и Tail. При добавлении еще одного узла в начало указатель Head начинает указывать на новый узел, а Tail не меняется. И так же добавляется указатель нового узла предыдущий (конечный), указатель узла Tail равен `null` так как это конечнй узел, и так далее каждый раз при добавлении 

`AddLast`
![[Pasted image 20230711102840.png]]

При добавлении первого элемента результат выглядит так же, как и в `AddFirst`. Добавляя еще 1 узел в конец, наблюдаем ту же картину, что и в предыдущем примере. Добавив второй узел, указатель узла Head (головной узел) не свдигается, а указатель Tail сдвигается на новый узел. Обновляем указатель последнего узла и так далее.

`RemoveLast`
Связные списки динамически расширяемы и не имеют доступа к узлам по индесам, недостатком является отсутсвие возможности добраться до индекса предпоследнего узла, в случае удаления последнего, так как нам нужно поменять его индекс на `null`. Чтобы провести такую операцию, надо взять головную ноду и итерировать список, пока не дойдем до предпоследнего узла, после этого можем обновить его индекс и обновить свойство Tail. 

`RemoveFirst`
В таком случае нужно просто сдвинуть индекс головного узла, тогда оставшийся без указателя узел будет очищен обработчиком мусора

# Двусвязный список (Double Linked list)

Пример двусвязного списка
![[Pasted image 20230712102841.png]]

Благодаря наличию указателей на предыдущий и последующий узлы, мы можем удалить послдений узел за константное время(Tail будет содержать ссылку на предыдущий узел). 
Основным недостатком **двусвязного списка** является то, что нам необходимо аллоцировать в два раза больше памяти относительно односвязного списка.

