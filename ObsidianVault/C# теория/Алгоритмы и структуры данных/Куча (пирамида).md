#СтруктурыДанных 
Это особый случай бинарного дерева. Чтобы бинарное дерево стало пирамидой оно должно стать завершенным бинарным деревом - бинарное дерево, в котором каждый уровень, исключая возможно последний, является полностью заполненным и все узлы находятся как можно левее

Какждый родительский узел должен быть больше либо равен своим дочерним узлам(максимальная пирамида - Max Heap), либо каждый родительский узел должен быть меньше или равен свои дочерним узлам(минимальная пирамида - Min Heap)

Пирамиды в памяти реализуются как массивы:
1. Корнем становится array[0]
2. Проходя по дереву, мы добавляем в массив значения на каждом уровне слева на право (реализуется так, для упрощения доступа к узлам по индексам)
![[Pasted image 20230806161623.png]]

## Вставка в пирамиду
1. Добавить элемент в конец массива
2. Затем "Heapify":
	1. сравнить добавленный элемент с родителем
	2. если элемент > родителя - поменять их местами
	3. повторять пока элемент не занял свое место
![[Pasted image 20230806162329.png]]

## Удаление из пирамиды
1. Необходима замена удаляемому элементу
2. Чтобы сохранять дерево в состоянии "complete", берем самое правое значение
3. Затем "heapify":
	1. если элемент > родителя - fix upwards (swim) смещаем наверх, пока не займет "свое" место
	2. если элемент < меньше родителя - fix downwards (sink), смещаем вниз пока не займет "свое" место

![[Pasted image 20230806164825.png]]
![[Pasted image 20230806164859.png]]

Характеристики производительности пирамиды:
1. Insert: O(log(n)) - логарифмическое
2. Remove: Max\Min: O(log(n)) - логарифмическое
3. Peek: O(1) - константное значение, так как максимальное\минимальное значение в пирамиде всегда находится в корневом узле
4. Если нужно запустить какой-лиюо поиск случайного значения в пирамиде - операция работает за линейное время, потому что пирамида никак не заточена под случайный доступ (быстрый случайный доступ - др структуры данных, пирамиды заточены под быстрый доступ к минимальным и максимальным значениям)