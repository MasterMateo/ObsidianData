#СтруктурыДанных 

![[Pasted image 20230803094649.png]]

1. Раздельные цепочки (separate chaining)
2. Открытая адресация (open addressment)

## Separate chaining

![[Pasted image 20230803093938.png]]

При добавлении элемента "е" возникает коллизия, мы присоединяем связный список к каждому индексу в массиве Buckets, посколько коллизии возникают очень редко это позволит использовать один и тот же индекс для разный пар ключ-значение. Когда клиент запрашивает значение по ключу "е", мы пойдем в индекс 3 и начнем просматривать соответствующий связный список и начнем просматривать каждый узел этого списка циклом "for", пока не найдем нужное нам значение. Этот варинт жизнеспособен, потому что хорошая хеш-функция с хорошим распределением повзволяет нам не получать урон по производительность (for будет очень короткий)

1. Хорошее распределение хеш-кодов - обязательное условие для хорошей производительности
2. Количество ключей в цепочке ~= N/M, где N - количество ключей, M - количество цепочек
3. Поиск и вставка работает за N/M ~= 1, если М достаточно велико (т.е. поиск и вставка работают за линейное время, если все реализованно корректно, включая метод хеширования). Если М не настолько велико, то время работы поиска и вставки будет близко к константе
4. Потребление памяти = 48N + 64M (для Java, близко к C#)

## Open addressment

![[Pasted image 20230803094715.png]]

Размер массива Buckets обычно больше, чем кол-во хранимых пар ключ-значение. Этот подход состоит в том, чтобы найти ближайший свободный в массиве слот и положить пару ключ-значение туда (положили в 4, такой алгоритм называется Linear Probing). В таком случае, когда клиент будет запрашивать значение по ключу "е", мы перейдем в индекс 3, вызовем метод Equals и увидим что пара ключ-значение, которая хранится по этому индексу не то, что нам нужно, и после этого мы будем итерировать по массиву Buckets, до тех пор, пока не найдем нужную пару ключ-значение. 
Чтобы не было сильной деградации по производительности при таком подходе, необходимо поддерживать отношение кол-ва элементов к размеру Buckets между 1/8 и 1/2(сохраняя размер Buckets на столько большим, чем кол-во хранимых элементов мы позволяем хеш-функции распределять элементы гораздо лучше, имея много свободных слотов), тогда кол-во проб(проба - 1 итерация в цикле линейного поиска) варьируется между 1.5 и 2.5!

1. Производительность зависит от N/M, где N - кол-во ключей, М - размер Buckets
2. а = N/M - фактор загрузки (load factor)
3. Поиск и вставка работает за константу, если кол-во проб выражено так же константой
4. 1.5 <= количество проб <= 2.5 если а < 1/2
5. 32N <= Потребление памяти <= 128N для Java (близко к C# в том числе)