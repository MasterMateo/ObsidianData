#Алгоритмы 

Это способ измерить, сколько по времени будет выполняться алгоритм

Нотация "О" большое описывает самый худший случай алгоритма, мы заинтересованы в его оценке больше всего. 
Полагаясь на худший случай мы гарантируем, что время исполнения программы не привысит определенные пределы.

Корректно описывать сложность через количество операций, выполняемых для достижения результата. 

==Временная сложность алгоритма отражает насколько возрастет кол-во операций при увеличении кол-ва входных параметров!==

![[Pasted image 20231224225459.png]]

1. __O(1)__ - константное время(элемент массива по индесу)
2. _O(log n)_ - сложность порядка log n(бинарный поиск). В худшем случае делаем столько операций, сколько массив делится на 2( массив из 8 элементов делится 3 раза, значит кол-во операций = log2(8)) 
3. __O(n)__ - линейное время выполнения(сумма элементов массива). Проходимся по всем элементам, чем больше массив тем дольше идти
4. _O(n log n)_ - линейно-логарифмическая сложность([[Сортировка слияниями (Merge sort)]], [[Быстрая сортировка (Quick sort)]]). Зачастую алгоритмы "разделяй и влавствуй"
5. _O(n^2)_ - сложность порядка n квадрат(поиск дубликатов в массиве). Пробегаем по массиву + еще 1 вложенный цикл([[Пузырькова соритровка (Bubble sort)]], [[Сортировка вставками (Insertion sort)]])
6. _O(n^3)_ - сложность порядка n в кубе(2 вложенных цикла)
7. _O(2^n)_ - экспоненциальная сложность(рекурсивный расчет чисел Фибоначчи). Количество вычислений удваивается при добавлении каждого нового элемента в набор данных 
	[[Рекурсия]]