#СтруктурыДанных 

ConcurrentQueue можно отнести к lock-free конкурентным структурам данных

В основу ConcurrentQueue заложена структура ring-buffer (В его основе лежит массив данных и 2 указателя – начало (start) и конец (end)). 
Сам ConcurrentQueue состоит из сегментов

![[Pasted image 20231225144107.png]]

В результате получается однонаправленный связанный список. Начало связанного списка задает m_head, конец – m_tail. Ограничения:  

- m_head сегмент может иметь пустые ячейки только слева
- m_tail сегмент может иметь пустые ячейки только справа
- если m_head = m_tail то пустые ячейки могут быть как слева, так и справа.
- В сегментах, между m_head и m_tail пустых ячеек быть не может

m_state – массив состояния ячеек, если значение true – элемент записан в ячейку, если false — еще нет. По сути, это некий «Commit» записи. Нужен он для того, чтобы между операциями увеличения индекса Interlocked.Increment и записью значения в m_array не произошло чтение элемента другим потоком.

```C#
index = Interlocked.Increment(ref this.m_high);
if (index <= 31)
{
     m_array[index] = value;
     m_state[index].m_value = true;
}
```