#SystemDesign 

1. [[Master-slave]]
	1. Пишем в мастер
	2. Читаем из слейвов или из мастера
	3. В случае падения мастера получаем downtime на запись(если заранее назначить слейва, который станет мастером то downtime сократится, слейв этот должен быть синхронным - паттерн Hot standby).
	4. Split brain - проблема, когда приложение переключилось на слейва, а мастер ожил. Чтобы решить делаем параметр generation на мастере, чтобы знать какой из них "моложе" и отключать "старшего"
2. [[Master - master]](когда не готовы терпеть downtime, пр. 2 дата центра )
	1. Если падает один мастер, мы переключаемся на второй мастер без downtime
	2. Пишем в разные мастера
	4. Читаем из слейвов и мастеров
	3. Появляются конфликты(если два разных мастер сервера одновременно изменяют один и тот же набор данных)
>[!info]-  Способы решения конфликтов
> - LWW(Last Win Write) - последний по времени пишет
> - Ранг реплик - задаем ранг репликам, при синхронизации выигрывает тот у кого ранг больше
> - Решение конфликтов на клиенте - клиент при получении данных сам решает консистентны ли они
> - [[Conflict-replicated data type (CRDT)]] 

3. [[Master - less]] (peer-2-peer архитектура, блокчейн, когда нет ярко выраженных узлов)
	1. Нет мастера, все узлы равны между собой
	2. Пишем в определенные ноды
	3. Читаем с определенных нод
	4. Как обеспечить согласованность данных (W - кол-во реплик, в которые пишу, R - кол-во реплик, с которых читаю, N - общее кол-во):
		1. W + R > N - гарантируется строгая согласованность
		2. W + R <= N - не гарантируется строгая согласованность
		3. R = 1 и W = N - система оптимизирована для быстрого чтения
		4. W = 1 и R = N - система оптимизирована для быстрой записи

