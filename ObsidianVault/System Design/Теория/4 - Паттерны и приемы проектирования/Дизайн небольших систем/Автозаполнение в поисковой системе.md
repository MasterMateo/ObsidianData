#SystemDesign 

Для такой системы очень важна скорость ответа. Мы подписываемся на стрим запроса, заполняем ==префиксное древо== и на основании этого древа мы отдаем ответы пользователю.

Так же чтобы избежать моргания подсказок поисковой системы при печати используются такие подходы как:
### 1. Debouncing
Сервис ждет, когда после последнего действия пользователя пройдет какой-то промежуток времени, а только потом отправляет запрос.
> [!info]- Пример
> Быстро печатаю начало поискового запроса, потом жду подсказки Гугла для автозаполнения

### 2. Throttling
Ограничиваем количество запросов, которые может отправить сервис в секунду
>[!info]- Пример
>Когда пользователь печатает поисковый запрос, сервис не отправляет запросы на каждый новый добавленный символ. Запрос отправляется раз в секунду

## Префиксное дерево

[Trie или префиксное дерево](https://habr.com/ru/companies/otus/articles/674378/) — это особый вид дерева поиска, в котором для ключей узлов обычно используются строки.

В базовой реализации каждый узел дерева содержит один символ и указатели на дочерние узлы. Ключ узла не хранится в явном виде — он вычисляется как путь от корня до узла.

Для пометки узлов, в которых содержатся действительные ключи, используется булевый флаг.

[[prefix-tree]]

На рисунке показано дерево с ключами: "geek", "genius", "gene" и "genetic". Закрашенные узлы представляют собой допустимые ключи.

Также для ускорения работы автозаполнения используются сжатые префиксные деревья, в листьях которых хранится информация о `N` самых популярных словах дальше

[[compressed-prefix-tree]]

> Для быстрого ответа этого подхода необходимо будет кешировать данные, что может быть дорого, ищите компромисс!

### Пакетное обновление префиксных деревьев

[[package-managed-prefix-trees-handling]]

Как быстро обновить префиксные деревья в таком случае?
1. Обычный редеплой - подготовили новую версию приложения, переключили на нее трафик
2. Атомарно свопнуть корни дерева - если хочу сделать апдейт внутри сервиса