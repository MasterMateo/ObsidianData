#SystemDesign 

Упал мастер, есть два слейва, как выбрать нового лидера?

### 1. Лизинг лидерства

[[lease-grant-leader]]

У нас есть key-value БД, которая выдает право лидерства. Изначально это право находится у мастера, он ходит в эту БД и каждые 5 секунд (например) продлевает это лидерство.

В случае падения мастера, запись о лидерстве удаляется через 5 секунд и первый из слейвов, кто успеет отправить запрос к БД получит это лидерство(такой будет только 1). 

Для того, чтобы не грузить запросами key-value БД, некоторые из них поддерживают функцию фолловеров, то есть слейвы не отправляют запросы в БД, пока там есть активная запись "о лидерстве"

### 2. Алгоритм забияки

У нас есть несколько узлов, у каждого свой вес (у новых узлов ранг ниже). Как только добавляется новый узел, он синхронизируется с мастером. 

При обнаружении, что мастер не доступен, этот узел инициирует событие "Выборов", раскидывает это событие узлам выше его рангом, узлы получившие это событие отвечают "Ок"

Далее узлы, получившие событие "Выборов", тоже раскидывают это событие узлам выше их рангом и узел не получивший ни одного "Ок" назначается главным, так как он является высшим по рангу. После этот узел отправляет всем узлам сообщение о том, что он новый мастер

### 3. Raft

Raft — это способ, с помощью которого группа серверов в распределённой системе договаривается о едином состоянии, даже если некоторые серверы могут выйти из строя или работать с задержками.

- **Роли серверов (лидер, кандидат, последователь):**  
    Каждый сервер в системе может находиться в одной из трёх ролей:
    
    - **Последователь (follower):** Обычный сервер, который ждёт указаний от лидера.
    - **Кандидат (candidate):** Если последователь долго не получает сообщений от лидера, он начинает "бороться" за лидерство, объявляя себя кандидатом.
    - **Лидер (leader):** Сервер, который получил большинство голосов от других серверов и теперь отвечает за координацию работы и распространение изменений.
    
- **Выбор лидера:**
    
    - Каждый сервер имеет свой таймер ожидания. Если сервер, находящийся в статусе последователь, не слышит от действующего лидера `heartbeat` в течение определённого времени, он предполагает, что лидер недоступен.
    - Тогда он переходит в статус кандидата и запускает выборы, отправляя запросы о голосовании всем остальным серверам.
    - Если кандидат получает большинство голосов, он становится лидером. Этот лидер теперь становится главным координатором системы.
    - При этом, возможно, несколько серверов одновременно могут перейти в статус кандидата, так как у них разные таймауты. 
    
>[!info]- Пояснение
>Остальные сервера(если они ещё не проголосовали в текущем терме) получают запрос кандидата. Каждый сервер проверяет:
>- Голосовал ли он уже в этом терме
>- Актуальность лога кандидата
>
>Если условия выполняются, то он отдает свой голос кандидату

- **Разрешение конфликтов:**
	
	- Если не набрал большинства:
	    - Может случиться, что несколько серверов одновременно стали кандидатами, и голоса распределились так, что ни у одного не получилось большинство.
	    - Тогда через случайный промежуток времени все кандидаты снова инициируют новый раунд выборов с увеличением терма.
	- При обнаружении более высокого терма:
	    - Если сервер получает запрос или сообщение от кандидата с более высоким термом, он автоматически переходит в состояние последователь и голосует за того кандидата.
    
- **Репликация логов:**
    
    - **Лог** — это последовательность команд или изменений, которые должны быть выполнены на всех серверах. Когда клиент отправляет команду, лидер добавляет её в свой лог.
    - После этого лидер рассылает эту команду (в виде сообщения AppendEntries) всем последователям.
    - Когда большинство серверов (лидер включён) подтвердят, что они записали эту команду, она считается **зафиксированной (committed)** и может быть применена к состоянию системы. Это гарантирует, что все серверы в итоге выполнят одну и ту же последовательность команд.
    
- **Обеспечение согласованности и безопасности:**
    
    - **Термы:** В Raft время разделено на периоды, называемые термами. Каждый новый выбор лидера начинается с нового терма. Если появляется более свежий термин, старые данные или лидерство отбрасываются.
    - **Согласование логов:** Если какой-то сервер отстаёт или его лог отличается, лидер следит за тем, чтобы в конечном итоге все логи синхронизировались. Он отправляет отсутствующие записи, и даже если какой-то сервер получил неправильные записи, они будут перезаписаны.
    - **Защита от конфликтов:** Если кандидат или лидер обнаруживает, что у него в логе записи, отсутствующие у других серверов, система гарантирует, что в будущем все изменения будут согласованы с тем, что уже зафиксировано большинством.

**Роли и обязанности лидера**

1. Запись операций в журнал:  
    Лидер инициирует запись операций в журнал и распространяет эти записи на следящих участников. Это обеспечивает согласованность данных между узлами.
    
2. Репликация данных:  
    Лидер отвечает за репликацию данных на другие участники системы. Он гарантирует, что записи в журнале будут воспроизведены на большинстве узлов.
    
3. Ответы на запросы клиентов:  
    Лидер обрабатывает запросы, поступающие от клиентов, и применяет их к своим данным. Затем он реплицирует изменения на следящих участниках.
    
4. Поддержание активности:  
    Лидер отправляет периодические сообщения (heartbeat) следящим участникам, чтобы поддерживать свою активность. Если следящий участник не получает такие сообщения в течение определенного тайм-аута, он может начать выборы.

### 4. Paxos

В Paxos выделяют три основных роли, которые могут исполнять серверы:

1. **Предлагающий (Proposer):**  
    Этот узел инициирует процесс, предлагая некоторое значение, которое должно быть принято системой.    
2. **Принимающий (Acceptor):**  
    Эти узлы отвечают за «голосование» за предложения. Чтобы значение было принято, оно должно получить поддержку большинства принимающих.    
3. **Узнающий (Learner):**  
    Эти узлы получают информацию о том, какое значение в итоге было принято большинством, чтобы вся система могла узнать результат консенсуса.

> Супер сложен в реализации!

>[!info]- Пример из жизни
>Представьте, что несколько друзей решают, в каком ресторане поужинать:
>1. **Предложение:**  
>Один из друзей (предлагающий) предлагает ресторан и отправляет сообщение всем другим (принимающим) с вопросом: «Могу ли я предложить этот ресторан?» При этом он указывает свой номер предложения (например, «предложение №5»). 
>2. **Обещание:**  
>Другие соглашаются не рассматривать предложения с меньшими номерами и отвечают, что пока других значимых предложений не было, они готовы рассмотреть этот вариант. 
>3. **Подтверждение:**  
>Получив ответы от большинства, предлагающий объявляет: «Ресторан №5 утверждён!»
>  
>Все друзья (участники) узнают о решении, и они идут в этот ресторан.
#### Особенности и гарантии Paxos

- **Надёжность при сбоях:**  
    Даже если некоторые узлы или сообщения недоступны, алгоритм продолжает работать, если большинство узлов функционирует правильно.
    
- **Гарантия безопасности:**  
    Paxos гарантирует, что если какое-либо значение принято большинством, то никакое другое значение не будет принято. Это обеспечивает согласованность системы.
    
- **Сложность реализации:**  
    Несмотря на кажущуюся простоту описания, алгоритм Paxos имеет множество нюансов (например, обработка повторных сообщений, таймаутов и конфликтов номеров предложений), что делает его реализацию достаточно сложной. Именно по этой причине на практике часто используют упрощённые варианты или альтернативы, например, алгоритм Raft, который спроектирован с акцентом на понятность.
    

1 37