#MSPatterns 

Проблема:
	Если при коммуникации микросервисов посредством публикации событий(изменение состояния какой-либо сущности в одном из микросервисов и для информирования других сервисов публикуется событие об изменение данной сущности)
	Сохранение состояния и публикация события не происходят атомарно, значит на любом этапе что-то может пойти не так.
Решение:
	В начале в рамках одной транзакции атомарно сохранять и изменения состояния и само событие(как привило в таблицу в Outbox бд), а вторым шагом выполнять публикацию ранее сохраненного события. После этого запускается отдельный процесс, который забирает сообщения из таблицы outbox и начинает их обработку.

[[TransactionalOutBox]]

### **Как сообщения хранятся в базе**

Это небольшая табличка, где есть Primary key, Payload, то есть тело нашего сообщения и статусы, по которым мы будем понимать, что с сообщением сейчас происходит.

#### Плюсы паттерна Outbox

1. **Решает проблему связи между сервисами.** Теперь не нужно беспокоиться, что брокер или сервис доставки будут недоступны. Все сообщения сохраняются в базу и будут обработаны, когда недоступные сервисы оживут.    
2. **Сообщения отправляются, только когда транзакция базы данных коммитится**. То есть у нас не получится так, что если нам не удалось сохранить заказ в базу, хотя мы сохранили сообщение в Outbox, то выполнится не нужная команда. Здесь гарантируется атомарность.  
#### Минусы паттерна Outbox

1. **Необходима база данных.** Если ее нет, то придется затащить эту зависимость, потому что сообщения обязательно нужно где-то хранить.     
2. **Дополнительная сложность эксплуатации и поддержки решения.** Появляются дополнительные зависимости: брокер сообщений и база данных. Необходимо всегда быть готовым к отказам одного или другого.
## Как бороться с дубликатами 

На стороне сервисов мы можем обеспечить exactly-once процессинг ([[Гарантии доставки сообщений]]). Как этого достичь? Есть несколько вариантов:

1. Хранить идентификаторы обработанных сообщений и проверять, когда сообщения нам приходят, что это не дубликат.    

**Важно**: если выбираем такой путь, то идентификатор должен устанавливаться на стороне приложения отправителя, чтобы со временем он не менялся.

2. У сервиса должна быть уникальная сущность, по которой мы можем понять, что нам пришло сообщение, с которым мы что-то уже до этого делали. Например, это может быть заказ.